import { exec } from 'child_process';
import { promisify } from 'util';
import { K8sClient } from '../k8s/k8s-client';
import { StoreModel, StoreStatus } from '../models/store';
import { StoreEventModel } from '../models/store-event';
import { logger } from '../utils/logger';
import { metrics } from '../utils/metrics';

const execAsync = promisify(exec);

export class Provisioner {
  private k8sClient: K8sClient;
  private storeModel: StoreModel;
  private eventModel: StoreEventModel;

  constructor() {
    this.k8sClient = new K8sClient();
    this.storeModel = new StoreModel();
    this.eventModel = new StoreEventModel();
  }

  async provisionStore(storeId: string): Promise<void> {
    const startTime = Date.now();
    const store = await this.storeModel.findById(storeId);
    if (!store) {
      throw new Error(`Store ${storeId} not found`);
    }

    if (store.status === StoreStatus.READY) {
      logger.info(`Store ${storeId} already provisioned`);
      return;
    }

    try {
      await this.storeModel.updateStatus(storeId, StoreStatus.PROVISIONING);
      await this.eventModel.create({
        storeId,
        action: 'provision',
        status: StoreStatus.PROVISIONING,
        message: 'Provisioning started'
      });

      // Step 1: Create namespace
      await this.ensureNamespace(store.namespace, storeId);

      // Step 2: Generate secrets
      await this.generateSecrets(store.namespace, storeId);

      // Step 3: Install Helm chart
      await this.installHelmChart(store, storeId);

      // Step 4: Wait for resources to be ready
      await this.waitForReady(store.namespace, storeId);

      // Step 5: Get store URL
      const url = await this.getStoreUrl(store.namespace, store.engine);

      // Step 6: Mark as ready
      await this.storeModel.updateStatus(storeId, StoreStatus.READY, undefined, url);
      await this.eventModel.create({
        storeId,
        action: 'ready',
        status: StoreStatus.READY,
        message: `Store ready at ${url}`
      });

      // Record metrics
      const duration = (Date.now() - startTime) / 1000; // seconds
      metrics.recordProvisioningDuration(storeId, duration);
      metrics.incrementStoresCreated(store.engine);

      logger.info(`Store ${storeId} provisioned successfully in ${duration.toFixed(2)}s`);
    } catch (error: any) {
      logger.error(`Failed to provision store ${storeId}:`, error);
      
      // Record failure metric
      metrics.incrementProvisioningFailures(storeId, error.message || 'unknown');
      
      await this.storeModel.updateStatus(
        storeId,
        StoreStatus.FAILED,
        error.message || 'Unknown error'
      );
      await this.eventModel.create({
        storeId,
        action: 'fail',
        status: StoreStatus.FAILED,
        error: error.message || 'Unknown error'
      });
      throw error;
    }
  }

  private async ensureNamespace(namespace: string, storeId: string): Promise<void> {
    logger.info(`Creating namespace ${namespace} for store ${storeId}`);
    await this.eventModel.create({
      storeId,
      action: 'provision',
      status: StoreStatus.PROVISIONING,
      message: `Creating namespace ${namespace}`
    });

    const exists = await this.k8sClient.namespaceExists(namespace);
    if (!exists) {
      await this.k8sClient.createNamespace(namespace);
    }
  }

  private async generateSecrets(namespace: string, storeId: string): Promise<void> {
    // Secrets will be generated by Helm chart
    logger.info(`Secrets will be generated by Helm chart for ${namespace}`);
  }

  private async installHelmChart(store: any, storeId: string): Promise<void> {
    logger.info(`Installing Helm chart for store ${storeId}`);

    const chartPath = './charts/medusa-store';
    const valuesFile = process.env.NODE_ENV === 'production' 
      ? './charts/medusa-store/values-prod.yaml'
      : './charts/medusa-store/values-local.yaml';

    // Determine host based on environment
    const host = process.env.NODE_ENV === 'production'
      ? `${storeId}.${process.env.DOMAIN || 'example.com'}`
      : `${storeId}.localhost.nip.io`;

    // Generate random password for PostgreSQL
    const postgresPassword = this.generatePassword();

    const helmCommand = `helm upgrade --install store-${storeId} ${chartPath} \
      --namespace ${store.namespace} \
      --create-namespace \
      -f ${valuesFile} \
      --set store.id=${storeId} \
      --set ingress.host=${host} \
      --set postgresql.auth.password=${postgresPassword}`;

    try {
      const { stdout, stderr } = await execAsync(helmCommand);
      if (stderr && !stderr.includes('Release')) {
        logger.warn(`Helm stderr: ${stderr}`);
      }
      logger.info(`Helm chart installed: ${stdout}`);
    } catch (error: any) {
      // Check if release already exists (idempotency)
      if (error.message.includes('already exists')) {
        logger.info(`Helm release already exists for ${storeId}, skipping install`);
        return;
      }
      throw error;
    }
  }

  private async waitForReady(namespace: string, storeId: string, timeout: number = 600000): Promise<void> {
    logger.info(`Waiting for store ${storeId} to be ready...`);
    
    const startTime = Date.now();
    const checkInterval = 10000; // 10 seconds

    while (Date.now() - startTime < timeout) {
      const isReady = await this.k8sClient.isDeploymentReady('medusa-api', namespace);
      
      if (isReady) {
        logger.info(`Store ${storeId} is ready`);
        return;
      }

      await this.sleep(checkInterval);
    }

    throw new Error(`Timeout waiting for store ${storeId} to be ready`);
  }

  private async getStoreUrl(namespace: string, engine: string): Promise<string> {
    // In local, use nip.io format
    // In production, use configured domain
    const storeId = namespace.replace('store-', '');
    if (process.env.NODE_ENV === 'production') {
      return `https://${storeId}.${process.env.DOMAIN || 'example.com'}`;
    }
    return `http://${storeId}.localhost.nip.io`;
  }

  async deleteStore(storeId: string): Promise<void> {
    const store = await this.storeModel.findById(storeId);
    if (!store) {
      throw new Error(`Store ${storeId} not found`);
    }

    try {
      await this.storeModel.updateStatus(storeId, StoreStatus.DELETING);
      await this.eventModel.create({
        storeId,
        action: 'delete',
        status: StoreStatus.DELETING,
        message: 'Deletion started'
      });

      // Step 1: Uninstall Helm release
      await this.uninstallHelmChart(store.namespace, storeId);

      // Step 2: Delete namespace (this will delete all resources including PVCs)
      await this.k8sClient.deleteNamespace(store.namespace);

      // Step 3: Remove from database
      await this.storeModel.delete(storeId);

      logger.info(`Store ${storeId} deleted successfully`);
    } catch (error: any) {
      logger.error(`Failed to delete store ${storeId}:`, error);
      await this.storeModel.updateStatus(
        storeId,
        StoreStatus.FAILED,
        `Deletion failed: ${error.message}`
      );
      throw error;
    }
  }

  private async uninstallHelmChart(namespace: string, storeId: string): Promise<void> {
    logger.info(`Uninstalling Helm chart for store ${storeId}`);

    const helmCommand = `helm uninstall store-${storeId} --namespace ${namespace}`;

    try {
      await execAsync(helmCommand);
      logger.info(`Helm chart uninstalled for ${storeId}`);
    } catch (error: any) {
      // If release doesn't exist, that's okay (idempotency)
      if (error.message.includes('not found')) {
        logger.info(`Helm release not found for ${storeId}, skipping uninstall`);
        return;
      }
      throw error;
    }
  }

  private generatePassword(): string {
    return Math.random().toString(36).slice(-16) + Math.random().toString(36).slice(-16);
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
